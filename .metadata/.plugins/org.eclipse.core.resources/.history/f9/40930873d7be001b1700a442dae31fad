package Algorithm;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Random;

public class QLearning {
	
	public static Random rnd = new Random(1);
	
	public static void Main(String[] args)
    {
    	System.out.println("Begin Q-learning maze demo");
    	System.out.println("Setting up maze and rewards");
        int ns = 12; // 12x12
        int[][] FT = CreateMaze(ns);
        System.out.println("Maze Matrix");
        Print(FT);
        double[][] R = CreateReward(ns);
        System.out.println("Reward Matrix");
        Print(R);
        double[][] Q = CreateQuality(ns);
        System.out.println("Quality Matrix");
        Print(Q);
        System.out.println("Analyzing maze using Q-learning");
        int goal = 11;
        double gamma = 0.5;
        double learnRate = 0.5;
        int maxEpochs = 1000;
        Train(FT, R, Q, goal, gamma, learnRate, maxEpochs);
        System.out.println("Done. Q matrix: ");
        Print(Q);
        System.out.println("Using Q to walk from cell 8 to 11");
        Walk(8, 11, Q);
        System.out.println("End demo");
    }
    public static void Print(double[][] Q)
    {
        int ns = Q.length;
        System.out.println("[0] [1] . . [11]");
        for (int i = 0; i < ns; ++i)
        {
            for (int j = 0; j < ns; ++j)
            {
            	System.out.println(Q[i][j].ToString("F2").PadLeft(1,' ') + " ");
            }
            System.out.println();
        }
    }

    public static void Print(int[][] Q)
    {
        int ns = Q.length;
        System.out.println("[0] [1] . . [11]");
        for (int i = 0; i < ns; ++i)
        {
            for (int j = 0; j < ns; ++j)
            {
            	System.out.println(Q[i][j].ToString("F2").PadLeft(1,' ') + " ");
            }
            System.out.println();
        }
    }
    public static void printR(int[][] Q, double[][] Q) {
    	int ns = Q.length;
        System.out.printf("%25s", "States: ");
        for (int i = 0; i <= ns; i++) {
            System.out.printf("%4s", i);
        }
        System.out.println();

        for (int i = 0; i < statesCount; i++) {
            System.out.print("Possible states from " + i + " :[");
            for (int j = 0; j < statesCount; j++) {
                System.out.printf("%4s", matrix[i][j]);
            }
            System.out.println("]");
        }
    }
    public static int[][] CreateMaze(int ns)
    {
        int[][] FT = new int[ns][];
        for (int i = 0; i < ns; ++i) FT[i] = new int[ns];
        FT[0][1] = FT[0][4] = FT[1][0] = FT[1][5] = FT[2][3] = 1;
        FT[2][6] = FT[3][2] = FT[3][7] = FT[4][0] = FT[4][8] = 1;
        FT[5][1] = FT[5][6] = FT[5][9] = FT[6][2] = FT[6][5] = 1;
        FT[6][7] = FT[7][3] = FT[7][6] = FT[7][11] = FT[8][4] = 1;
        FT[8][9] = FT[9][5] = FT[9][8] = FT[9][10] = FT[10][9] = 1;
        FT[11][11] = 1;  // Goal
        return FT;
    }
    public static double[][] CreateReward(int ns)
    {
        double[][] R = new double[ns][];
        for (int i = 0; i < ns; ++i) R[i] = new double[ns];
        R[0][1] = R[0][4] = R[1][0] = R[1][5] = R[2][3] = -0.1;
        R[2][6] = R[3][2] = R[3][7] = R[4][0] = R[4][8] = -0.1;
        R[5][1] = R[5][6] = R[5][9] = R[6][2] = R[6][5] = -0.1;
        R[6][7] = R[7][3] = R[7][6] = R[7][11] = R[8][4] = -0.1;
        R[8][9] = R[9][5] = R[9][8] = R[9][10] = R[10][9] = -0.1;
        R[7][11] = 10.0;  // Goal
        return R;
    }
    public static double[][] CreateQuality(int ns)
    {
        double[][] Q = new double[ns][];
        for (int i = 0; i < ns; ++i)
            Q[i] = new double[ns];
        return Q;
    }
    public static List<int> GetPossNextStates(int s, int[][] FT)
    {
        List<int> result = new List<int>();
        for (int j = 0; j < FT.Length; ++j)
            if (FT[s][j] == 1) result.Add(j);
        return result;
    }
    static int GetRandNextState(int s, int[][] FT)
    {
        List<int> possNextStates = GetPossNextStates(s, FT);
        int ct = possNextStates.Count;
        int idx = rnd.Next(0, ct);
        return possNextStates[idx];
    }

    /**
     * loop maxEpochs times
      set currState = a random state
      while currState != goalState
        pick a random next-state but don't move yet
        find largest Q for all next-next-states
        update Q[currState][nextState] using Bellman
        move to nextState
      end-while
    end-loop
     */
    static void Train(int[][] FT, double[][] R, double[][] Q,
      int goal, double gamma, double lrnRate,
      int maxEpochs)
    {
        for (int epoch = 0; epoch < maxEpochs; ++epoch)
        {
            int currState = rnd.Next(0, R.length);
            while (true)
            {
                int nextState = GetRandNextState(currState, FT);
                List<int> possNextNextStates = GetPossNextStates(nextState, FT);
                double maxQ = double.MinValue;
                for (int j = 0; j < possNextNextStates.Count; ++j)
                {
                    int nns = possNextNextStates[j];  // short alias
                    double q = Q[nextState][nns];
                    if (q > maxQ) maxQ = q;
                }
                Q[currState][nextState] =
                      ((1 - lrnRate) * Q[currState][nextState]) +
                      (lrnRate * (R[currState][nextState] + (gamma * maxQ)));
                currState = nextState;
                if (currState == goal) break;
            } // while
        } // for
    } // Train
    static void Walk(int start, int goal, double[][] Q)
    {
        int curr = start; int next;
        System.out.println(curr + "->");
        while (curr != goal)
        {
            next = ArgMax(Q[curr]);
            System.out.println(next + "->");
            curr = next;
        }
        System.out.println("done");
    }
    static int ArgMax(double[] vector)
    {
        double maxVal = vector[0]; int idx = 0;
        for (int i = 0; i < vector.length; ++i)
        {
            if (vector[i] > maxVal)
            {
                maxVal = vector[i]; idx = i;
            }
        }
        return idx;
    }


} // Program